#!/bin/bash

# #"exec" "$(dirname ${BASH_SOURCE[0]})/python3" "$0" "$@"

import shutil
import sys
import subprocess

from pathlib import Path

package_platform_override = {
    # pin the platform tag for a certain package and OS
    # "linux": {"numpy": "manylinux1_x86_64"}
}


def load_requirements(os_name):
    packages = []
    requirements = Path(f"requirements_{os_name}.txt").read_text(encoding="utf-8")
    packages = (
        line.split("#")[0].split(";")[0].strip() for line in requirements.splitlines()
    )  # remove comments
    return [p for p in packages if p]  # remove empty entries


PIP = [sys.executable, "-m", "pip", "--disable-pip-version-check"]


def split_special_cases(requirements: list, default_platforms: list, overrides: dict):
    for package_name, platform in overrides.items():
        requirement = next((r for r in requirements if r.startswith(package_name)), None)
        requirements.remove(requirement)
        assert platform in default_platforms
        yield [f"--platform={platform}", requirement]
    if requirements:
        yield [*[f"--platform={p}" for p in default_platforms], *requirements]


def create_universal_wheels():
    print()
    print("Creating universal wheels of sdists")
    blacklist = [
        # "Pillow"
    ]
    pip_wheel = [*PIP, "wheel", "--no-deps", "--wheel-dir=wheels"]
    for requirement in Path("wheels").glob("*.tar.gz"):
        if blacklist_entry := next((b for b in blacklist if b in requirement.stem), None):
            print("Ignoring", requirement, "(known not universal)")
            blacklist.remove(blacklist_entry)
            continue

        print("Building wheel for", requirement)
        result = subprocess.run(
            [*pip_wheel, str(requirement)],
            check=True,
            capture_output=True,
        )
        # print(result.stdout.decode())
        assert "none-any.whl" in result.stdout.decode()
        requirement.unlink()

    assert not blacklist, f"Build wheel blacklist outdated, unused {blacklist}"


def create_wheels():
    print("Creating wheels of sdists")
    blacklist = []
    wheel_list = ["Pillow"]
    pip_wheel = [*PIP, "wheel", "--no-deps", "--wheel-dir=wheels"]
    for requirement in Path("wheels").glob("*.tar.gz"):
        if blacklist_entry := next((b for b in blacklist if b in requirement.stem), None):
            print("Ignoring", requirement)
            blacklist.remove(blacklist_entry)
            continue

        if requirement.startswith(tuple(wheel_list)):
            print("Building wheel for", requirement)
            result = subprocess.run(
                [*pip_wheel, str(requirement)],
                check=True,
                capture_output=True,
            )
            # print(result.stdout.decode())
            assert "none-any.whl" not in result.stdout.decode()
            # requirement.unlink()

    assert not blacklist, f"Build wheel blacklist outdated, unused {blacklist}"


def download_packages(version, logger=print):
    """Download python packages for both Windows and Linux - including sources for debug build"""
    if Path("wheels").exists() and all(
        Path(f).stat().st_mtime <= Path("wheels").stat().st_mtime
        for f in [
            "requirements_centos.txt",
            "requirements_linux.txt",
            "requirements_windows.txt",
            __file__,
        ]
    ):
        print("wheels up-to-date. rerun pip-compile or touch requirements_*.txt to force download")
        return

    major, minor, *_ = version.split(".")
    print("Downloading packages")
    shutil.rmtree("wheels", ignore_errors=True)

    pip_download_args_common = [
        "--dest=wheels",
        "--no-deps",  # already taken care of pip-compile
        "--implementation=cp",
        f"--python-version={major}{minor}",
        f"--abi=cp{major}{minor}",
    ]

    os_platforms = [
        [
            "linux",
            [
                "manylinux_2_17_x86_64",
                "manylinux2014_x86_64",
                "manylinux_2_12_x86_64",
                "manylinux2010_x86_64",
                "manylinux_2_5_x86_64",
                "manylinux1_x86_64",
            ],
        ],
        [
            "centos",
            [
                "manylinux_2_17_x86_64",
                "manylinux2014_x86_64",
                "manylinux_2_12_x86_64",
                "manylinux2010_x86_64",
                "manylinux_2_5_x86_64",
                "manylinux1_x86_64",
            ],
        ],
        ["windows", ["win_amd64"]],
    ]

    for os_name, platforms in os_platforms:
        print(f"Downloading for platform {os_name}")
        requirements = load_requirements(os_name)

        special_cases = package_platform_override.get(os_name, {})
        for platforms_requirements in split_special_cases(requirements, platforms, special_cases):
            subprocess.run(
                [
                    *PIP,
                    "download",
                    *pip_download_args_common,
                    *platforms_requirements,
                ],
                check=True,
            )


if __name__ == "__main__":
    __path__ = [str(Path(__file__).parent)]  # make relative import work

    download_packages("3.11.2")
    create_universal_wheels()
    create_wheels()
